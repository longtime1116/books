[CDP](http://aws.clouddesignpattern.org/index.php/%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%9A%E3%83%BC%E3%82%B8)

# 事前
- [x] 基本用語
- [x] クラウドコンポーネント

# デザインパターン
## 基本のパターン
- [x] Snapshotパターン（データのバックアップ）
  - EBS(Amazon Elastic Block Store) を使って snapshot を取得する。snapshot は S3 に保存される。ちなみに RDS の DB インスタンスは、データベースおよびログのストレージに EBS を使っている。
- [x] Stampパターン（サーバの複製）
  - EC2 から AMI(Amazon Machine Images) を作れば、AMI を基に複数の EC2 を作成できる。環境設定済みの仮想サーバを複製できる。
- [x] Scale Upパターン（動的なサーバのスペックアップ／ダウン）
  - スペックが不足や過剰ならばあとから変えれば良い。small -> micro にしたり、small -> xlarge にしたり。CloudWatch などでリソース利用量を把握すると良い。なお、変更時には EC2 インスタンスを一旦停止する必要がある。
- [x] Scale Outパターン（サーバ数の動的増減）
  - Scale Up パターンでスペックを上げることはできるが、限界があるし、スペックを上げると単価は上がる。そこで、同じようなスペックのサーバーを複数台並べ、高トラフィックのリクエストを処理する。時間帯でトラフィックが激しく増減するケースなどはこのパターンを採用すると良い。
  - ELB 配下に EC2 を複数並べる。EC2 を自動で起動するようの AMI を用意しておく。EC2 の平均 CPU 使用率、ネットワーク流量、セッション数、EBS のレイテンシーなどを条件として CloudWatch で監視する。アラームを受けて Auto Scaling が EC2 数を増減するように設定する。
- [x] Ondemand Diskパターン（動的なディスク容量の増減）
  - EBS を利用していてより大きな容量が必要となったら、その EBS を基にスナップショットを取り、そのスナップショットを基に新しい EBS を作成。その際により大きな容量を指定すれば良い。
  - EBS は S3 とは異なり、確保したディスク容量に対して課金する。
## 可用性を向上するパターン
- [x] Multi-Serverパターン（サーバの冗長化）
  - ELB を使って処理分散をしましょうという話。ヘルスチェック機能があるから障害が起きても安心。
- [x] Multi-Datacenterパターン（データセンターレベルの冗長化）
  - ELB にぶら下げる EC2 の AZ を別のところにしておくとより安心だよという話。料金は変わらない。
- [x] Floating IPパターン（IPアドレスの動的な移動）
  - EIP(Elastic IP Address) を EC2 につけておき、障害時は別のインスタンスにデタッチする。
- [x] Deep Health Checkパターン（システムのヘルスチェック）
  - 図の具体例は、例えば web が BFF で、proxy が API Gateway で、app が API サーバ。
  - app が n 台あってそのうち一部が障害になっていたとする。その際、url に対して設定しているヘルスチェックは毎回失敗するわけではないが、たまに一部の app を叩いたときに障害と判定される。
- [x] Routing-Based HAパターン（ルーティングによる接続先の透過的な切り替え）
  - サブネット（AZ）をまたいで冗長化されたEC2のフェイルオーバー（接続先の切り替え）を行うことができる。
  - VPCは、ネットワークのルーティングを API を使って変更できる。ルーティングを切り替えるスクリプトを用意しておき、アクティブなEC2で障害が発生したらそのスクリプトを実行してフェイルオーバーさせる。
## 動的コンテンツを処理するパターン
- [x] Clone Serverパターン（サーバのクローン）
  - 単一のサーバ構成から、負荷分散を考慮したシステムに変える。ELBを用意し、そこに既存のEC2をぶら下げる。クローン用EC2はAMIを用いて用意する。
- [x] NFS Sharingパターン（共有コンテンツの利用）
  - 複数サーバで負荷分散した時に、コンテンツを同期させなければならないケースがある。その場合、NFS(Network File System)サーバとして EC2 を1台用意し、そこでコンテンツを共有する。
  - 要はデータを置く場所とデータを処理する場所を分離すればいいという話の具体例のひとつか。
- [x] NFS Replicaパターン（共有コンテンツの複製）
  - NFS Shareing パターンでは、NFS を共有するサーバが増えアクセス頻度が高くなると、SPOF となる可能性が高まる。
  - NFS サーバのファイルを、各 EC2 の仮想ディスクである EBS にコピーしておく。
    - read するときはこれを見れば良い。
    - write するときは同期が必要
  - Auto Scaling で起動する EC2 については、起動時にまず NFS サーバをマウントし、さらに NFS サーバの内容を EBS にコピーする。
- [x] State Sharingパターン（ステート情報の共有）
  - NFS Sharing パターンの、KVS 版。セッション情報などは インメモリキャッシュや KVS に保存して置くと良い。ElastiCache（Memcached、Redis)、DynamoDB など。
- [x] URL Rewritingパターン（静的コンテンツの退避）
  - 仮想サーバへのアクセスの負荷のうち、静的コンテンツへのアクセスを分離する。
  - EC2 の静的コンテンツ(JavaScript/CSS/画像など) を、S3 にアップロードする。
  - 必要に応じて、その S3 をオリジナルとした CloudFlont を作成する。
  - HTML タグ上の静的コンテンツの URL を S3 もしくは CloudFlont のものに置き換える(動的に置き換える方法もあるし、CloudFlont を使えばパスパターンによってS3を参照するようにできる)。
  - CloudFlont を使うと全世界配信に対する距離を起因とするレイテンシー対策になる。しかし、コンテンツがキャッシュされるので削除や更新に時間がかかる場合がある。
- [x] Rewrite Proxyパターン（URL書き換えプロキシの設置）
  - 既存システムを修正せずに、静的コンテンツへの負荷分散を実現できる。
  - ELB と S3 の間に、Nginx などを用いたプロキシサーバ(EC2)を配置する。
  - プロキシサーバに、コンテンツ内の URL の書き換えルールを追加する。
- [x] Cache Proxyパターン（キャッシュの設置）
  - 高負荷対策で Web/API サーバを複数台利用するとコスト負担が重くなる。そこで、Cache 用のサーバを ELB と Web/API サーバ(EC2) の間に噛ませる。
  - Varnish などのよく使われているキャッシュサーバソフトを EC2 にインストールして配置。オリジナルデータのサーバやキャッシュ期限などを設定する。
- [x] Scheduled Scale Outパターン（サーバ数のスケジュールにあわせた増減）
  - Auto Scaling を使う時に、時間指定で EC2 インスタンスを増加させることが可能。
- [x] IP Poolingパターン（接続許可済みIPアドレスのプール）
  - Elastic IP を必要な個数確保して、S3 にその IP アドレスの列挙をテキストファイルとして保存しておく(IPアドレスリスト)
  - オートスケーリングで EC2 を起動する際、
    - IPアドレスリストのパスをタグにセットする。
    - EC2 の初期化スクリプトで、タグに設定されたパスを基に、S3 から IPアドレスリストを取得する。
  - 自分のインスタンスのリージョンにある ElasticIP のなかで未使用のものの一覧を取得し、自身のインスタンスに紐づける。
## 静的コンテンツを処理するパターン
- [x] Web Storageパターン（可用性の高いインターネットストレージ活用）
  - S3 に大きいサイズをおいて、直接そこにアクセスしてダウンロードさせるようにすることができる。ネットワーク負荷を減らせる。
- [x] Direct Hostingパターン（インターネットストレージで直接ホスティング）
  - S3 に静的なコンテンツを置いて、それをユーザが直接
  - S3のWebサイトホスティング機能をオンにし、インデックスページやエラーページを設定することで、S3単体でWebサイトをホストできる。
- [x] Private Distributionパターン（特定ユーザへのデータ配布）
  - Webサーバ を立ててそこで制限付き URL を取得するようにする。そして、その URL を用いて S3 からコンテンツをダウンロードする。
  - そうすることで、特定のユーザに飲みコンテンツを配布する、ということが実現できる。
- [x] Cache Distributionパターン（ユーザに物理的に近い位置へのデータ配置）
  - 物理的に遠い地域からのアクセスに対するレスポンスは、遅れがち。日本と米国東海岸だと、最低でも200msくらいの遅延が発生してしまう。
  - AWS の ClouodFlont を使用すると、エッジサーバーとしてのキャッシュサーバを立てることができる。
- [x] Rename Distributionパターン（変更遅延のない配信）
  - Cache Distribution パターンで、マスターサーバのファイルを変更しても、キャッシュの期限が切れるまでは更新されない。
  - そこで必要なものに関しては、更新したいファイルを違うファイル名で配置してアクセスURL自体を変更することで、新しいコンテンツを配信する。
- [x] Private Cache Distributionパターン（CDNを用いたプライベート配信）
  - まずはオリジナルの Web サーバで署名付き URL/Cookie を作成し、それを元にエッジサーバからコンテンツをダウンロードするようにすると、特定のユーザへの配信が可能になる。
- [x] Latency Based Origin（地域によりオリジンサーバを変更）
  - エッジサーバを使っても、初回アクセス時はキャッシュがないので遅くなってしまう。でもオリジンを分けたとしても同じ URL でアクセスさせたい。
  - オリジンサーバを複数用意して、同一のコンテンツを保持させておく。オリジンにアクセスする際に使用する DNS 名を登録し、その際に1つの DNS 名に対して複数のオリジンサーバの DNS を登録し、さらにそれを地理的に近いオリジンを返すように設定する。
  - オリジン同士のコンテンツの同期には、CMSの配布機能、rsync、GlusterFSのGeoReplicationなどを使う。
  - Amazon Route53 で名前解決して最寄りのオリジンサーバに問い合わせる
## データをアップロードするパターン
- [x] Write Proxyパターン（インターネットストレージへの高速アップロード）
  - S3 は読み込みに対するキャパシティやデータの耐久性が非常に高い一方、書き込み速度が比較的劣るという性質がある。
    - 冗長性を保つために複数ロケーションに書き込んでいたり、HTTPプロトコルでクライアントと通信したりしているから。
  - アップロードサーバとしての EC2 サーバを立てて、まずそこにクライアントからデータを転送する。小さいファイルが大量にある場合は、一旦クライアントで一つのファイルにまとめる。
  - その後、アップロードサーバから S3 に転送する。クライアントでアーカイブした場合は、アップロードサーバで解凍後に S3 に転送する。
- [x] Storage Indexパターン（インターネットストレージの効率化）
  - S3 は高度な検索機能がないので、特定のユーザのデータ一覧を取得したり、ある日付範囲のデータを取得したりする場合、アプリケーション側で工夫が必要になる。
  - そこで検索性能の高い KVS にもメタ情報を格納しておくようにして、それをインデックスとして利用する。
  - S3 のメタ情報(キー、パス、データサイズ、格納時間など)を DynamoDB(もしくはSimpleDB) に格納しておく。
  - 検索や集計は DynamoDB を利用して処理を行う
  - DynamoDB の処理結果を元に、S3からデータを取ってくる。
  - AWS Lambda を利用することで、S3 にファイルがアップロードされたことをトリガーにして自動的にインデックス化を実施できる。
  - データの登録とメタ情報の登録は、必ず同時に行うべし！！
- [x] Direct Object Uploadパターン（アップロード手順の簡略化）
  - サイズの大きなデータがアップロードされる時、サーバに負荷がかかる。特にネットワークの負荷。
  - なので、直接インターネットストレージにアップロードできるようにする。
  - EC2 では S3 へのアップロードを行う HTML のフォームを作成する。
  - アップロードフォームを利用し、ユーザ側からS3に直接アップロードする。
  - S3 へのファイル転送完了後、フォームに指定してある URL へリダイレクトされるので、リダイレクト先のサーバでアップロード終了の確認処理を行う。
## リレーショナルデータベースのパターン
- [x] DB Replicationパターン（オンラインDBの複製）
  - 同一リージョンの異なるAZで、2台の EC2 を用意する。
  - それぞれの EC2 に RDBMS をインストールし、レプリケーション設定を行う。
  - こうすることで、災害や障害が発生しても、システムを止めることなくレプリケーションしているデータベースにアクセス先を切り替えることができる。
  - Aurora を使うと 3 つのアベイラビリティーゾーン間でデータのコピーが 6 個作成される！！
- [x] Read Replicaパターン（読込専用レプリカによる負荷分散）
  - DB へのアクセス頻度が高いとき、データベースの読み込み処理を分散してシステム全体のパフォーマンス向上を図る手がある。
  - マスター DB から読み込み専用の Read Replica を作成する。
  - 複数のリードレプリカを作成することも可能だが、アプリケーション側で振り分ける必要がある。HAProxy, MySQL Proxy などのッミドルウェアがあるらしい。
  - 一般にリードレプリカは非同期のレプリケーションなので、マスターとリードレプリカの間には若干のラグが存在する。要注意。
- [x] Inmemory DB Cacheパターン（頻度の高いデータのキャッシュ化）
  - ElastiCache(memcached or Redis) を使い、データベースから読み込んだデータをキャッシュしておく。
  - そうすることで、データベースからの読み込みパフォーマンスを改善でき、システム全体のパフォーマンス向上につながる
  - プログラムを修正する必要がある。キャッシュがあれば ElastiCache を読み、そうでなければ DB を見て、その結果を ElastiCache に書き込む
- [x] Sharding Writeパターン（書き込みの効率化）
  - シャーディングソフトウェアを載せた EC2 を用意し、そこから複数のバックエンドDB(RDS)に分散して書き込めば、書き込みのパフォーマンスが上がる。
  - シャーディングとは？DBを垂直分割して負荷分散を行うやり方。ユーザIDの偶数奇数で分けるとか。
## 非同期処理/バッチ処理のパターン
- [x] Queuing Chainパターン（システムの疎結合化）
  - 複数システムで処理を連携させて逐次的な処理を行う場合、システムをできるだけ疎結合にしたい。
  - システム間をキューでつなぎ、ジョブの受け渡しをメッセージの送受信で行うようにする。そうすれば、メッセージを受け取って処理する仮想サーバを増やして並列処理できるようになる。
  - 仮想サーバに障害が起きても、未処理のメッセージはキューに残るので、処理の再開が用意。
  - EC2 から SQS にメッセージを送る(Put)。SQS のメッセージをEC2から受信する(Get)
  - SQS ではキューから取り出す際の順序は保証されていないので注意が必要
- [x] Priority Queueパターン（優先順位の変更）
  - プライオリティキューを実現するため、SQS を複数用意する。優先度が高い方はプライオリティキューに渡し、低い方はセカンダリーキューに渡すようにする。
  - プライオリティキューの方は高い性能で処理するとよい。
- [x] Job Observerパターン（ジョブの監視とサーバの追加・削除）
  - バッチ処理の負荷分散のためにバッチ処理サーバを並列したい。
  - CloudWatch で SQS のキューの数を監視し、閾値を超えたら AutoScaling により EC2 を追加することができる
  - EC2 は時間単位で課金され、短時間でも一度起動して終了しても1時間分の課金がかかるので注意が必要
- [x] Fanoutパターン（複数種類の処理を非同期かつ並列に実行）
  - バッチ処理で逐次実行することは可能だが、それぞれ別々のサーバで並列実行したほうが早く済むというケースがある
  - そういうときは、EC2 から SNS へメッセージを送り、SNS が 複数の SQS にメッセージを送る。
  - SQS のメッセージを各処理サーバが受け取って並列に処理する。
  - 各処理が疎結合になるので、処理の追加や一部処理のリソース増強などが行いやすい
## 運用保守のパターン
- [x] Bootstrapパターン（起動設定の自動取得）
  - AMI を変化適応しやすくする。(いちいち再作成する必要がなくなる)
  - EC2 の初期化に必要なパラメータを S3 に配置して、EC2 起動時にそのパラメータファイルを読み込み動的に自分自身を構築するようにしておく。
  - Amazon Linux には cloud-init という初期化機能があり、ユーザデータ領域に初期化スクリプトを書いておくことで、自動的に実行することができる
- [x] Cloud DIパターン（変更が多い部分の外出し）
  - EC2 にタグをつけることができる。
  - タグとは、1 つのキーとオプションの 1 つの値で構成されている。完全に文字列として解釈されるもの。
  - 例えば EIP をタグとして設定しておき、EC2 の起動時にタグを取得するアプリケーションが実行されるようにしておく。
  - そのとき、アプリケーション内でタグ情報に従ってEC2の初期化を行うようにしておく。(設定した EIP を EC2 に割り当てる)
  - すると、Stamp パターン等でスケールさせた EC2 それぞれに対して固有の設定を行うことができる。
  - DI は Directory Index の略？
- [x] Stack Deploymentパターン（サーバ群立ち上げのテンプレート化）
  - CloudFormation を使うと、どんな構成でサーバ群を立ち上げるかを定義し、一気に自動で起動することができる。
  - 破棄も行える
  - CloudFormation は staging/production など環境ごとに設定をすることができる。
  - infrastracture as a code
  - CloudFormer といツールを使うと既存システムからテンプレートを作成することができる
- [ ] Server Swappingパターン（サーバの移行）
- [ ] Monitoring Integrationパターン（モニタリングツールの一元化）
- [ ] Weighted Transitionパターン（重みづけラウンドロビンDNSを使った移行）
- [ ] Log Aggregation パターン(ログの集約)
- [ ] Ondemand Activationパターン（メンテナンス時の一時的な設定変更）
## ネットワークのパターン
- [ ] Backnetパターン（管理用ネットワークの設置）
- [ ] Functional Firewallパターン（階層的アクセス制限）
- [ ] Operational Firewallパターン（機能別アクセス制限）
- [ ] Multi Load Balancerパターン（複数ロードバランサの設置）
- [ ] WAF Proxyパターン（高価なWeb Application Firewallの効率的な活用）
- [ ] CloudHubパターン（VPN拠点の設置）
- [ ] Sorry Pageパターン(バックアップサイトへの自動切り替え)
- [ ] Self Registrationパターン（自分の情報をデータベースに自動登録）
- [ ] RDP Proxyパターン（Windowsインスタンスへのセキュアなアクセス）
- [ ] Floating Gatewayパターン（クラウド上のネットワーク環境の切り替え）
- [ ] Shared Serviceパターン(システム共通サービスの共用化)
- [ ] High Availability NATパターン(冗長化されたNATインスタンス)
