実践ドメイン駆動設計


# 第0章

## DDDの概要
### 戦略的モデリング
### アーキテクチャ


* 例
  * itemドメインモデル: validationとか、item情報をまとめるとか。(rails でいう model ではこういうことをやっている)
  * アプリケーション: ロジック
  * アダプター: API、APIのインターフェースを最初に吸収する場所
* この六角形ひとつが境界づけられたコンテキストと一対一対応



### 戦術的モデリング

* 集約
  * 自転車集約のなかに、value object/entitiy がたくさんあるイメージ(車輪オブジェクト、タイヤオブジェクト)

* 例
  * 集約1
    * aggregate root: 自転車
    * entity: 車輪
    * entity: タイヤ
    * value object: 位置(実態があるものではないが、あったほうが良いもの)
  * 集約2
    * aggregate root: エンジン
* 外部からは、aggregate root(集約ルート)にしかアクセスできない
* リポジトリ
  * 集約に必要なものをまとめてこいつに渡すと、集約のインスタンスを作ってDBとかにアクセスして保存する。
  * 保存するだけでなく、検索とかもやらせる。
* rails においては、model が集約とリポジトリを兼ねている => まさに model

* service は複数の集約にまたがる操作を実行する
* クエリ操作が参照系、コマンド操作が更新系

* イベント
  * 集約がイベントを作成してイベントを作成して、イベントパブリッシャーに渡す
  * イベントパブリッシャーがイベントを発火する。各サブスクライバに処理を委ねる。
  * ex. ユーザコンテキストの集約がユーザ削除イベントを作成してイベントパブリッシャーに渡す。イベントパブリッシャーはユーザへメールを送るサブスクライバや、itemコンテキストにも削除を依頼するサブスクライバに処理をお願いする。

* モジュール
  * 外部公開されない集約

# 第1章

## 1.3
* ユビキタス言語をドキュメント化してそれを保存するのは得策ではない。
* チームでの会話やコード内のモデルが今のドメインのユビキタス言語で表現されているので、それが正である。

## 1.4
* 技術的な面白みというよりも、事業価値を高めることに繋がることに良さがある。
* コアドメインに力を入れる => 場合によってはモノリシックな「その他」ドメインができたりするのだろうか？ => 多分それをやってもいい。
  * コアドメインを汚さないように隔離することで、最低限のラインを保てる。
* うまく設計されたモデルと単にセッターゲッターを設定しただけのモデルの関係は、Ruby と C++ の違いに似たものを感じた。すなわち、文脈を意識して使い所に即したものをユーザに提供するかどうかという意味合いにおいて。

## 1.5
* 戦略だけやって戦術はやらない、みたいな方法はとるとどうなる？
  * 境界づけられたコンテキストでドメインが別れているので、大負けはしない。
  * が、そのドメインの中がごちゃごちゃになるので戦術的モデリングをやった方が良い。


# 第2章

## 2.1
* 広義のドメインの中にコアドメインとサブドメインがある。
* サブドメインとコアドメインの違い => 後者はビジネス的な価値の源泉となるもの
* 汎用サブドメインとしてのロギング機能とかは、複数の協会づけられたコンテキストにまたがる、サブドメインとなる。
* 「サブドメインは、複数の境界づけられたコンテキストにかかわっているだろうか？もしそうだとしても、別に問題はない。業務ソフトウェアとはそういうものだ。」
  * ひとつのサブドメインのなかに複数の境界づけられたコンテキストがあるケース
    * SEOサブドメインの中に sitemap コンテキストと canonical コンテキストがある、とか。
    * これは普通にあってよい
  * 一つの境界づけられたコンテキストが複数のサブドメインに関わっているケース
    * 外部サービスを買ってきたケース(ERPとか)
    * pixta.git みたいなモノリスもこれにあたると思われる
    * これはできれば避けたい

## 2.2
* コンテキストはライブラリという形でも良い(3.1にある、共有カーネル)。
  * したがってユーザ認証コンテキストとか、パーミッションコンテキストとかもAPIコール出なくて↑みたいにやることも可能。

## 2.3
* 問題空間と解決空間
  * 前者は、問題発見フェーズ。
    * そもそもそのドメインにおける問題発見をするためには、どのようなサブドメインからドメインが成り立ち、そのサブドメインがどのような関係性を持っているかを明確に理解しておく必要がある。
    * なので、それを考えるのが問題空間
  * 後者は、前者で見つけたドメインをどう現実的に実現するか。問題解決フェーズ。
    * なので、境界づけられたコンテキスト(アーキテクチャと対応することが多い)を見つけてそれをどう実装するかを考えることになる。
* 図2.4 とその後の「そのドメインの各部分を担当するのは誰？」からわかるように、チーム分割はドメインの境界面で行う！！！
* ERP を何も考えずに使っていると、コンウェイの法則に従って ERP チームみたいになってしまうだろうが、それだと問題空間を反映したものとなっていないので、適切なビジネス課題の発見ができないだろう。
* 問題空間(サブドメイン)を解決空間で表す時に、複数の境界づけられたコンテキストがあることは普通にあり得る。
  * 特に外部のAPIを叩く時には必ずそうなるんじゃないかな？

## 2.4
* サブドメイン、境界づけられたコンテキストは、問題空間の概念
* items の場合だと、審査前、審査中、審査後とかでわけてそれぞれ別の境界づけられたコンテキストを用意して、別のDBを用意して入れておくことになる。
* 境界づけられたコンテキストは、言語により規定されるので、ドメインモデル以外のものが入ってもよい。
* 境界づけられたコンテキストを考える際に、アーキテクチャ境界やチーム境界のことを考えるべきではない
* 境界づけられたコンテキストを GitHub のリポジトリと対応させると、場合のよってはいい感じになりそう？
  * そのなかに rails アプリケーション用のディレクトリを掘ってそこにアプリケーションを置いて、別のディレクトリにはそのユビキタス言語で表される処理をするスクリプトが置いてあったり。

## 2.5
* 責務のレイヤ => イメージとしては、認証をmoduleに切り出し、model の中でそれを取り込む感じか。その場合レイヤは別れているがモデルに残り続けていることは変わらない
* 隔離されたコア => 認証を model に切り出してしまい、手前のアプリケーションサービスから認証の model と別の model に順番にアクセスする感じか。
* カウボーイの会話: 共通の鍵を用意して、その鍵を受け取った人は全てのサイロに入れる、みたいにするべき

# 第3章
## 3.1
* 腐敗防止層(AntiCorruptionLayer)
  * 基本的には必要不可欠。なぜなら、言語の区切りが境界づけられたコンテキストの区切りだから。
  * 下流側が腐敗防止層
* 公開ホストサービス(OpenHostSeavice)
  * 「サブシステムにアクセスできるようにするプロトコルを、サービスの集合として定義すること」
    * APIを提供する的な。
* 公表された言語(PublichedLanguage)
  * 供給者側が、「こういう言語で公開しているから使ってね」としているもの
  * 本を読む感じ、二つの境界づけられたコンテキストの間での共有言語をもとに公表するように見えるが、これは無理があるのでは？と感じた。それだと、O(n^2)のペースで公表された言語が増えていく。
  * 供給者側がユビキタス言語で公表する方が良いのでは？
* ↓でペアなイメージ
  * パートナーシップ と 順応者
  * 顧客/供給者の関係 と 腐敗防止層/公開ホストサービス/公表された言語
* 下流のモデルがなるべく上流のモデルに依存しないようにするやつ、どう実装するのだろうか？
  * 例えば認証コンテキストのアーキテクチャが停止したらどうするのだろうか？
  * 腐敗防止層でエラー処理ちゃんとするということかと思った。
  * ログイン情報を保存しておいて、一定時間は認証コンテキストを叩かなくて済む、みたいにするのもありか。

* RPC は internal API をイメージすれば良い。
* 依存性を減らすのであれば、キャッシュとかで必要な最小限の状態だけを、そのローカルのドメインオブジェクトとして変換して持っておく。
* 同期は、リモートシステム側からの通知。
* 同じイベントを重複して処理しないようにケアするのは、クライアント側の責務


# 4章
## 4.1
* Rails でいうと、
  * UI: view
  * アプリケーション: controller
  * ドメイン: model から db とのmapperの部分を除いた者
  * インフラ: mapperとDB、外部API叩く層など
* 「リポジトリインターフェイスが要求している実装が。永続化メカニズムなどのコンポーネントを要求するものであり、それはインフフラストラクチャに存在するものだとしよう」？？？

## 4.2
* ドメイン層はビジネスに依存しており、それ以外には依存しないようにしたい。
* ドメインが変わればドメインに依存している他の全てが変わるのは問題ないが、ビジネス以外のことが変わってドメインが変わるのはおかしい。
* ドメインがインフラに依存している状況: ドメインで update するときに MySQLClient.update() みたいなことをしていたら、そうなっている
* ドメインがインフラに依存していない状況: UserRepository.update_user_name とかにしておき、UserRepository の内部で DB を選んで接続している場合とか

## 4.3
* ヘキサゴナルアーキテクチャ
  * アプリケーションサービスとドメインモデルを内部に置き、それとそれ以外をきっぱり分けて、I/Oに依らず統一的なインタフェースを使うようにする

## 4.4
* SOA(Service Oriented Architecture)
  * アプリケーションサービスとドメインモデルがまずあり(境界づけられたコンテキストに基づく)、そいつらをうまく使えるラッパー的なノリでサービスというのを用意する
  * サービスはユースケースにあわせて作られるが、ドメインモデルがそれに依ってはならない
  * 図4-5 のアダプターEは、ORMapper とかか。

## 4.5
* REST
  * リソースに対して何かする、という感じにしなければならないのに、まとめていろんなことをやってしまうことがあって、それはアンチパターン

## 4.6 CQRS
* Read(クエリ)とWrite(コマンド)が別々に分かれていると、view依存の物を完全に分けることができる
* コマンドはそれに対応する結果確認用のクエリを概念上考えることができるので、クエリ集合からコマンド集合に対する全射fを定義できそうだなとか思った。

## 4.7 イベント駆動アーキテクチャ
* リアルタイムでユーザに結果を伝える必要がないものについては有用。
* イベントソーシング
  * ドメインモデル内の任意の集約のインスタンス上で実行された全ての操作コマンドを、その実行結果を示す少なくとも一つのドメインイベントとして発行する。
  * それを繰り返せば状況が再現できるようなもの。
  * ヘキサゴナルアーキテクチャを跨いでいるから、そういうことが必要になる(ひとつのアーキテクチャの中だったら、ソースコード読めば済むし)
* ピクスタではデジタル素材を扱っているがゆえに、カスタマー側を考えるとこういう非同期処理はなかなか出てこない

## 4.8
* キャッシュに残しておけばパフォーマンスが上がるよね => データファブリック
* 集約そのものをシリアライズ、と書いてあったので Ruby でいうと Marshal 使うみたいな感じなのだろうか


# 5章 エンティティ
## 5.1
* ドメインモデルは、エンティティと値オブジェクトのどちらかに大別される。
* アイデンティティを持たないものが値オブジェクト。id が違うなら違うもの、とするのがエンティティ。
## 5.2
* エンティティのユニークIDをどう生成し保持していくか、という話が書いてある。4つのやり方。
  * ユーザが入力
  * アプリケーションが内部で生成
  * データベースなど永続化層が生成
  * 別の境界づけられたコンテキストのものを使う

## 5.3
* 具体、という感じ。
* バリデーションをエンティティ自体がしなくても良いが、クライアント側からはエンティティがやっているように見せる必要がある(安心させることができる)。エンティティ自体がしない、というのは、specific なバリデーションクラスみたいなのを用意してそれをエンティティが呼び出せば良い、という意味



# 6章 値オブジェクト
## 6.1
* value_object.rb に例を書いた

## 6.2
* API提供側ではエンティティだが、使う側では値オブジェクトとする。と良い。Read only なときは特にそう。
* write するときは、下流側でもエンティティを定義する、という選択肢もある。できれば避けたいが。

## 6.3
* enum の値をインスタンス変数として持つとか、継承でもできそうだし、依存オブジェクトの注入

## 6.4
* ドメインのインタフェースを考えようという話かと。

## 6.5
* 値オブジェクトのコンストラクタ二つ。
  * ひとつは属性全てを引数に取り、新規作成するもの
  * もう一つは、シャローコピーするもの。(それが適切な値オブジェクトならば、ディープコピーの必要性はないはず) 

## 6.6
* 「可能な限り、ドメインモデルを考慮してデータモデルを設計するようにしよう。ドメインモデルがデータモデルの設計に縛られるようではいけない。前者はドメインモデルの視点で考えるということであり、後者は永続化の視点でかんがえるということになる」
* 「基本的なアイデアは、値を保持するエンティティが格納されているテーブルの行に、値の各属性に対応したカラムを用意するというものだ」言い換えると、単一の値オブジェクトを非正規化して、親のエンティティの行に組み込むということになる。」
* ↑のふたつが言っていることから考えたこと
  * Rails でモデルがどういうものなのかを調べるときに、とりあえずDBのテーブル定義を見ることがある。しかしこれは、DDD 的な発想ではないと言える。
  * あくまでドメインモデルの I/F から出発すべき。
  * ただし、Rails においてはモデルとDBが密結合なので、こういうことをしてしまうのは自然であり、それにより問題は起きない。


# 7章 サービス
## 7.1
* ここでは、ドメインサービスについて扱っている。
* アプリケーションサービスはドメインの外にあるものだが、ドメインサービスはドメインの一部。
* ピクスタでいうと SitemapGenerator 。
* rails でいう controller はアプリケーションサービスか。userが解約するときにuserのステータスとitemの停止を同時に行うときに、解約を行う処理はドメインサービスとなる。
* カウボーイの声。ドメインサービスはステートレスで永続化しないので、「それが何であるのかは別に気にしなくていい」つまり、バリデーションはしなくていいということ。

## 7.2
* 具体例
## 7.3
* UserDescriptor クラスを作ってそいつに tenantId と userId を持たせる。というところが面白い。
  * authenticate した場合のみ見れる情報を持たせる
* 自分だったら AuthenticationService().exec とかして、その戻り値を boolean にしてしまっていたかも。
## 7.4
* セパレートインタフェース
  * EncryptionServiceインターフェースをドメインモデルに置き、その暗号化の具体的な方法はインフラストラクチャ側で行う。そうすると、MD5以外の暗号化に変えることが容易になる。


# 8章 ドメインイベント
## 8.1
* メーセージキューとか、非同期実行もドメインイベントか。
## 8.2
* 例えば imasia から pixta に対して、ダウンロードされたことを伝える時は？
  * 「ダウンロードされました」イベントなのか、「クレジット付与してくれ」イメントや「クリエイターにメールしてくれ」イベントなのか
  * 前者だろう。あくまでパブリッシャ側のユビキタス言語で。
  * 誰に通知するのか？をimasiaは知っているのか？
* 「軽量なサブスクライバ」と書いてあるやつは、中継をしている。すなわち、イベントパブリッシャーが発行したイベントをサブスクライブし、必要としているサブスクライバのメッセージキュー(サブスクライバと一対一対応と考えている)にパブリッシュする。
  * 中継している主体は、何が来たらどれとどれに送るか、を知っているが、それは「XXXが来たらそれは私のメッセージキューに積んでください」と各ドメインがその主体にお願いした結果そうなっている的なイメージ。
  * 中継している主体は汎用サブドメインなのではないか？サブスクライバにメッセージを送り続け、それをうまく処理できたかを確認するが、うまく処理できていなかったらエラー通知をする、とか

## 8.3
* domain_event.rb に書いた
* Rails でいうと ActiveJob でできる
* サブスクライバをパブリッシャーに登録するのはアプリケーションサービスにおいて。

## 8.4
* 以下のいずれかでパブリッシュしたイベント情報を永続化する
  * 1. メッセージング基盤の永続化ストアを全サービスで共有する
  * 2. ドメインモデルの永続化ストアとメッセージング用の永続化ストアを二相コミットで制御する
  * 3. ドメインモデルの使っているデータストアそれぞれでメッセージング基盤の永続化ストアを保持する
* RPCとは、処理を外部システムに任せて結果を受け取ること
* RPC(リモートプロシージャコール)を避けることで、他システムからの高いレベルでの独立性が達成される。
  * どのくらいの遅延が許容されるのかもあわせて考慮する

## 8.5
* 単一の境界づけられたコンテキスト内の全てのドメインイベントを、イベントストアに収容する
* モデルにメッセージが送られたときに発火する処理を仕込み、そこで保存するのは、その時点のbeforeのインスタンスと、それに送るメッセージと、引数のはず。

## 8.6
* 格納したイベントを通知する方法をどれにするか
  * RPC
  * RESTベースの通知(アーカイブログとカレントログをREST形式で提供する。必要な人に取って行ってもらう)
  * メッセージング
* RESTベースの通知が適するのは、多数のクライアントがたった一つのURLを使って同じ通知を要求するケース
* メッセージングが適するのは、クライアントが多くの通知を取りに行かなければならない時。(たくさんのRESTベースの通知を非同期で取得すると、順番が問題になる)

# 9章 モジュール
## 9.1
* ドメインモデルをまとめるモジュールの場合は、entity, value object, service, event を横串で特定の意味合い(境界づけられたコンテキスト！！)でパッケージングしたもの
* モジュール選択時は、ユビキタス言語を用い、ビジネス上の概念の凝集した集合を含んでいるものを選ぶべし。
## 9.2/9.3
* プロダクト名をモジュール名としない！！！
* ディレクトリ構造の例
  * com.saasovation.identityaccess.domain.model
    * ここに Service や Entity の抽象基底クラスを作るなどする
    * identityaccess が、ほぼほぼ境界づけられたコンテキスト
* [GitHub](https://github.com/VaughnVernon/IDDD_Samples/tree/master/iddd_agilepm/src/main/java/com/saasovation/agilepm/domain/model)

## 9.4
* 「モジュール」という言葉が別の意味で使われている。
  * 問題空間でいう境界づけられたコンテキストを、解決空間に対応させたものとしてのモジュール
  * ドメインモデルのひとつとしてのモジュール
* 例
  * subscription_buisiness.domain.models
    * contractor
    * download
    * plan
    * subscription(planへの参照があり、単一方向の依存関係)

## 9.6
* 境界づけられたコンテキストで分断する前に、モジュール単位を考える方がいい。
  * モジュール内部に複数の境界づけられたコンテキストが存在する方が、複数の境界づけられたコンテキストにモジュールがまたがる方が厳しいので。

# 10章 集約
## 10.1
* 集約とは？
  * 例えば、自動車というエンティティがあったとして、それのパーツとしてのタイヤ・車輪・位置があったときに、タイヤ等を外部からは見えないけど内部的には存在しているようにする。このように複数のエンティティ/値オブジェクトを集約とし、外部からは隠蔽する(自動車は集約ルートと呼ぶ)。
## 10.2
* トランザクション整合性と結果整合性
  * 集約はトランザクション整合性の境界と同義
* ひとつのトランザクションでひとつの集約のインスタンスしか変更できない、が望ましい。
* ここでいう集約のパーツ(エンティティ/値オブジェクト)は例えばDBのテーブルとは直接的には関係ないことに注意したいと思った。
## 10.3
* 適切に設計すると、かなりの割合で集約にはルートエンティティ以外にはエンティティは存在しない、ルートエンティティ+いくつかの値オブジェクトとなる。
* その結果、パフォーマンスやスケーラブリティの面で有利になるし、トランザクションも成功しやすくなる
* 新しいユースケースが集約を大きくすることを求めてくるかもしれないが、結果整合性を保つだけで回避できないかを考えるのは重要となる。
## 10.4
* 集約から直接別の集約の参照を参照するのではなく、識別子を持たせるのみにする。
  * トランザクション整合性が保てなくなるので(これはその参照先をwriteするかしないかに依らない)。

## 10.5
* 結果整合性とトランザクション整合性のどっちを採用するかの指針として、
  * ユースケースを実行するのがユーザ自身: 結果整合性
  * 別のユーザ(あるいはシステム): トランザクション整合性
    * ex. クレジット付与

## 10.8

* ルート以外の集約はエンティティではなく値オブジェクトを使おう、とあるので、永続化するときは、例えばDBであれば一つのテーブルに全てのカラムがあってもいいということになりそう(?)
* 依存オブジェクトの注入を使ってリポジトリやドメインサービスを集約に差し込むのは望ましくない。
  * たとえばリポジトリやドメインサービスへの参照をアプリケーションサービスに注入するとかならとても有用。

# 11章 ファクトリ
## 11.1
* 集約のインスタンスを作るためのもの。
* 集約ルートにファクトリメソッドがあるのが基本
* しかし、そうでないケースでファクトリが必要になることもある
  * 境界づけられたコンテキストを結合する際、あるコンテキスト側から他のコンテキストの情報を引っ張ってきてあわせてひとつの集約とみなすときは、それ用のドメインサービスがファクトリとして機能する
  * アブストラクトファクトリを用意し、パラメータを渡したらファクトリが自身でどの子クラスのインスタンスを作るかを判断する、みたいなことができる
* カウボーイの声の解釈
  * 消火栓ファクトリは集約ルートのファクトリメソッドであり、そのメソッドは、他のパーツをたくさん作る。パーツをたくさん作るのに人がたくさん必要なので、人々が車でやってくる。だから、駐車スペースがもうない

## 11.2 集約ルート上のファクトリメソッド
* これがまさに別の集約のインスタンスを作るファクトリメソッド。本棚と本の関係に近い。本棚に本を登録する際は、本棚にメッセージを送るのが自然。しかし、本が本棚の集約パーツというわけではない。

## 12 リポジトリ
* 永続させるすべての集約型は、リポジトリを持っている。集約型とリポジトリは一対一対応となっていることが多い。
* 裏側の実装にどんな永続化メカニズムを使っていようが、同じオブジェクトを複数追加できるようにしてはいけない。また、リポジトリから取得したオブジェクトを変更したときに、それをリポジトリに「書き戻す」必要がないようにしなければいけない。
* 集約というのは一つのドメインモデルから成り立つというケースがありえるか？=>あり得ても良い。なぜなら、集約というのは外から見たら集約ルートの存在しか見えないはずだから。
  * となると、単一のドメインモデルに対してリポジトリが用意されても良い。
## 12.4
* ユーザーインターフェースレイヤ、アプリケーションレイヤ、ドメインレイヤ、インフラストラクチャレイヤ(4章)
* アプリケーションレイヤにファサードとしてのビジネスメソッドを用意し、そこでトランザクションを貼る
* 「ドメインモデルおよびそれを取り巻くドメインレイヤは、トランザクション管理をする場所としてはまったく不適切だ。」
  * リポジトリの章のなかにあるので、ここでいうトランザクションは "複数のインスタンスに対して処理を行う際のトランザクション" を意味しているのでは。
  * なので、ここでドメインモデルに書いていけないというのは、"複数のインスタンスの状態を変えるようなメソッドを外部に公開してはならない" ということなのではないか

## 12.6
* DAOの機能は、テーブルモジュール・テーブルデータゲートウェイ・アクティブレコード等があるらしい

# 13章 境界づけられたコンテキストの統合
## 13.1
* 利用者側にインタフェースやクラスを渡してdeserializeさせる形式は、例えば aws-sdk とか別のやり方だとpixtacoreとか。
  * 境界づけられたコンテキストが混ざらないように適切に腐敗防止層を用意しなきゃならないと思う。
  * aws-sdk みたいな支援サブドメインとか汎用サブドメインならなら密結合になりにくいのでこの方式でもありかも。

## 13.2
* 腐敗防止層はアダプターと変換サービスの組み合わせとなるのが一般的
  * アダプターでリクエスト送って、得られたものを変換サービスでその境界づけられたコンテキスト内のユビキタス言語で表す値オブジェクトに変換する
  * アダプターが infrastructures の下にある。ヘキサゴナルアーキテクチャの概念図を思い出せば分かるように、他のマイクロサービスもDBの値をドメインモデルのインスタンスに変換するのも、等価に扱えるので。
* HATEOAS含むRESTの思想は、それのみで運用しようとするとマイクロサービスにおけるドメインモデル貧血症みたいな症状を引き起こしかねないのでは。なので、RESTとそうでないものを必要に応じて組み合わせていくのが良いのではないか。




# 14章 アプリケーション
* 図を見るとインフラストラクチャが勝手にいろいろなものを dispach していてよくわからないが。。。

## 14.1
* DTO(データ変換オブジェクト) と DPO(ドメインペイロードオブジェクト)
  * 例えばRailsでviewに値を渡す時に、Userモデルのインスタンスを渡しちゃうのがDPO。nameとかを一個一個渡すのがDTOかなと思った。ロジックを廃して渡すのがDTO。
* 多重ディスパッチは振る舞い的には依存性の注入と同じような感じ？
## 14.2
* アプリケーションサービスの責務はユースケースのフローにおけるタスクの調整であり、フローごとに一つのメソッドが存在する
  * Rails のコントローラーはアプリケーションサービスと捉えることができるだろう。
  * あるマイクロサービスにおいて個別具体的なユースケースに対応する必要があるとして、そのマイクロサービスの外の都合に合わせたAPIを生やすのは許されるのだろうか？
    * 基本的には個々のAPIを生やしてそれを使う側が組み合わせるのが良いはず。
    * 非機能要件のためにしかたなくまとめたAPIを用意しなきゃいけないこともある。
    * GraphQL API を使えばうまくいくじゃん！！！
