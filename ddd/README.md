実践ドメイン駆動設計


# 第0章

## DDDの概要
### 戦略的モデリング
### アーキテクチャ


* 例
  * itemドメインモデル: validationとか、item情報をまとめるとか。(rails でいう model ではこういうことをやっている)
  * アプリケーション: ロジック
  * アダプター: API、APIのインターフェースを最初に吸収する場所
* この六角形ひとつが境界づけられたコンテキストと一対一対応



### 戦術的モデリング

* 集約
  * 自転車集約のなかに、value object/entitiy がたくさんあるイメージ(車輪オブジェクト、タイヤオブジェクト)

* 例
  * 集約1
    * aggregate root: 自転車
    * entity: 車輪
    * entity: タイヤ
    * value object: 位置(実態があるものではないが、あったほうが良いもの)
  * 集約2
    * aggregate root: エンジン
* 外部からは、aggregate root(集約ルート)にしかアクセスできない
* リポジトリ
  * 集約に必要なものをまとめてこいつに渡すと、集約のインスタンスを作ってDBとかにアクセスして保存する。
  * 保存するだけでなく、検索とかもやらせる。
* rails においては、model が集約とリポジトリを兼ねている => まさに model

* service は複数の集約にまたがる操作を実行する
* クエリ操作が参照系、コマンド操作が更新系

* イベント
  * 集約がイベントを作成してイベントを作成して、イベントパブリッシャーに渡す
  * イベントパブリッシャーがイベントを発火する。各サブスクライバに処理を委ねる。
  * ex. ユーザコンテキストの集約がユーザ削除イベントを作成してイベントパブリッシャーに渡す。イベントパブリッシャーはユーザへメールを送るサブスクライバや、itemコンテキストにも削除を依頼するサブスクライバに処理をお願いする。

* モジュール
  * 外部公開されない集約

# 第1章

## 1.3
* ユビキタス言語をドキュメント化してそれを保存するのは得策ではない。
* チームでの会話やコード内のモデルが今のドメインのユビキタス言語で表現されているので、それが正である。

## 1.4
* 技術的な面白みというよりも、事業価値を高めることに繋がることに良さがある。
* コアドメインに力を入れる => 場合によってはモノリシックな「その他」ドメインができたりするのだろうか？ => 多分それをやってもいい。
  * コアドメインを汚さないように隔離することで、最低限のラインを保てる。
* うまく設計されたモデルと単にセッターゲッターを設定しただけのモデルの関係は、Ruby と C++ の違いに似たものを感じた。すなわち、文脈を意識して使い所に即したものをユーザに提供するかどうかという意味合いにおいて。

## 1.5
* 戦略だけやって戦術はやらない、みたいな方法はとるとどうなる？
  * 境界づけられたコンテキストでドメインが別れているので、大負けはしない。
  * が、そのドメインの中がごちゃごちゃになるので戦術的モデリングをやった方が良い。


# 第2章

## 2.1
* 広義のドメインの中にコアドメインとサブドメインがある。
* サブドメインとコアドメインの違い => 後者はビジネス的な価値の源泉となるもの
* 汎用サブドメインとしてのロギング機能とかは、複数の協会づけられたコンテキストにまたがる、サブドメインとなる。
* 「サブドメインは、複数の境界づけられたコンテキストにかかわっているだろうか？もしそうだとしても、別に問題はない。業務ソフトウェアとはそういうものだ。」
  * ひとつのサブドメインのなかに複数の境界づけられたコンテキストがあるケース
    * SEOサブドメインの中に sitemap コンテキストと canonical コンテキストがある、とか。
    * これは普通にあってよい
  * 一つの境界づけられたコンテキストが複数のサブドメインに関わっているケース
    * 外部サービスを買ってきたケース(ERPとか)
    * pixta.git みたいなモノリスもこれにあたると思われる
    * これはできれば避けたい

## 2.2
* コンテキストはライブラリという形でも良い(3.1にある、共有カーネル)。
  * したがってユーザ認証コンテキストとか、パーミッションコンテキストとかもAPIコール出なくて↑みたいにやることも可能。

## 2.3
* 問題空間と解決空間
  * 前者は、問題発見フェーズ。
    * そもそもそのドメインにおける問題発見をするためには、どのようなサブドメインからドメインが成り立ち、そのサブドメインがどのような関係性を持っているかを明確に理解しておく必要がある。
    * なので、それを考えるのが問題空間
  * 後者は、前者で見つけたドメインをどう現実的に実現するか。問題解決フェーズ。
    * なので、境界づけられたコンテキスト(アーキテクチャと対応することが多い)を見つけてそれをどう実装するかを考えることになる。
* 図2.4 とその後の「そのドメインの各部分を担当するのは誰？」からわかるように、チーム分割はドメインの境界面で行う！！！
* ERP を何も考えずに使っていると、コンウェイの法則に従って ERP チームみたいになってしまうだろうが、それだと問題空間を反映したものとなっていないので、適切なビジネス課題の発見ができないだろう。
* 問題空間(サブドメイン)を解決空間で表す時に、複数の境界づけられたコンテキストがあることは普通にあり得る。
  * 特に外部のAPIを叩く時には必ずそうなるんじゃないかな？

## 2.4
* サブドメイン、境界づけられたコンテキストは、問題空間の概念
* items の場合だと、審査前、審査中、審査後とかでわけてそれぞれ別の境界づけられたコンテキストを用意して、別のDBを用意して入れておくことになる。
* 境界づけられたコンテキストは、言語により規定されるので、ドメインモデル以外のものが入ってもよい。
* 境界づけられたコンテキストを考える際に、アーキテクチャ境界やチーム境界のことを考えるべきではない
* 境界づけられたコンテキストを GitHub のリポジトリと対応させると、場合のよってはいい感じになりそう？
  * そのなかに rails アプリケーション用のディレクトリを掘ってそこにアプリケーションを置いて、別のディレクトリにはそのユビキタス言語で表される処理をするスクリプトが置いてあったり。

## 2.5
* 責務のレイヤ => イメージとしては、認証をmoduleに切り出し、model の中でそれを取り込む感じか。その場合レイヤは別れているがモデルに残り続けていることは変わらない
* 隔離されたコア => 認証を model に切り出してしまい、手前のアプリケーションサービスから認証の model と別の model に順番にアクセスする感じか。
* カウボーイの会話: 共通の鍵を用意して、その鍵を受け取った人は全てのサイロに入れる、みたいにするべき

# 第3章
## 3.1
* 腐敗防止層(AntiCorruptionLayer)
  * 基本的には必要不可欠。なぜなら、言語の区切りが境界づけられたコンテキストの区切りだから。
  * 下流側が腐敗防止層
* 公開ホストサービス(OpenHostSeavice)
  * 「サブシステムにアクセスできるようにするプロトコルを、サービスの集合として定義すること」
    * APIを提供する的な。
* 公表された言語(PublichedLanguage)
  * 供給者側が、「こういう言語で公開しているから使ってね」としているもの
  * 本を読む感じ、二つの境界づけられたコンテキストの間での共有言語をもとに公表するように見えるが、これは無理があるのでは？と感じた。それだと、O(n^2)のペースで公表された言語が増えていく。
  * 供給者側がユビキタス言語で公表する方が良いのでは？
* ↓でペアなイメージ
  * パートナーシップ と 順応者
  * 顧客/供給者の関係 と 腐敗防止層/公開ホストサービス/公表された言語
* 下流のモデルがなるべく上流のモデルに依存しないようにするやつ、どう実装するのだろうか？
  * 例えば認証コンテキストのアーキテクチャが停止したらどうするのだろうか？
  * 腐敗防止層でエラー処理ちゃんとするということかと思った。
  * ログイン情報を保存しておいて、一定時間は認証コンテキストを叩かなくて済む、みたいにするのもありか。

* RPC は internal API をイメージすれば良い。
* 依存性を減らすのであれば、キャッシュとかで必要な最小限の状態だけを、そのローカルのドメインオブジェクトとして変換して持っておく。
* 同期は、リモートシステム側からの通知。
* 同じイベントを重複して処理しないようにケアするのは、クライアント側の責務


# 4章
## 4.1
* Rails でいうと、
  * UI: view
  * アプリケーション: controller
  * ドメイン: model から db とのmapperの部分を除いた者
  * インフラ: mapperとDB、外部API叩く層など
* 「リポジトリインターフェイスが要求している実装が。永続化メカニズムなどのコンポーネントを要求するものであり、それはインフフラストラクチャに存在するものだとしよう」？？？

## 4.2
* ドメイン層はビジネスに依存しており、それ以外には依存しないようにしたい。
* ドメインが変わればドメインに依存している他の全てが変わるのは問題ないが、ビジネス以外のことが変わってドメインが変わるのはおかしい。
* ドメインがインフラに依存している状況: ドメインで update するときに MySQLClient.update() みたいなことをしていたら、そうなっている
* ドメインがインフラに依存していない状況: UserRepository.update_user_name とかにしておき、UserRepository の内部で DB を選んで接続している場合とか

## 4.3
* ヘキサゴナルアーキテクチャ
  * アプリケーションサービスとドメインモデルを内部に置き、それとそれ以外をきっぱり分けて、I/Oに依らず統一的なインタフェースを使うようにする

## 4.4
* SOA(Service Oriented Architecture)
  * アプリケーションサービスとドメインモデルがまずあり(境界づけられたコンテキストに基づく)、そいつらをうまく使えるラッパー的なノリでサービスというのを用意する
  * サービスはユースケースにあわせて作られるが、ドメインモデルがそれに依ってはならない
  * 図4-5 のアダプターEは、ORMapper とかか。

## 4.5
* REST
  * リソースに対して何かする、という感じにしなければならないのに、まとめていろんなことをやってしまうことがあって、それはアンチパターン

## 4.6 CQRS
* Read(クエリ)とWrite(コマンド)が別々に分かれていると、view依存の物を完全に分けることができる
* コマンドはそれに対応する結果確認用のクエリを概念上考えることができるので、クエリ集合からコマンド集合に対する全射fを定義できそうだなとか思った。
