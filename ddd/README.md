実践ドメイン駆動設計


# 第0章

## DDDの概要
### 戦略的モデリング
### アーキテクチャ


* 例
  * itemドメインモデル: validationとか、item情報をまとめるとか。(rails でいう model ではこういうことをやっている)
  * アプリケーション: ロジック
  * アダプター: API、APIのインターフェースを最初に吸収する場所
* この六角形ひとつが境界づけられたコンテキストと一対一対応



### 戦術的モデリング

* 集約
  * 自転車集約のなかに、value object/entitiy がたくさんあるイメージ(車輪オブジェクト、タイヤオブジェクト)

* 例
  * 集約1
    * aggregate root: 自転車
    * entity: 車輪
    * entity: タイヤ
    * value object: 位置(実態があるものではないが、あったほうが良いもの)
  * 集約2
    * aggregate root: エンジン
* 外部からは、aggregate root(集約ルート)にしかアクセスできない
* リポジトリ
  * 集約に必要なものをまとめてこいつに渡すと、集約のインスタンスを作ってDBとかにアクセスして保存する。
  * 保存するだけでなく、検索とかもやらせる。
* rails においては、model が集約とリポジトリを兼ねている => まさに model

* service は複数の集約にまたがる操作を実行する
* クエリ操作が参照系、コマンド操作が更新系

* イベント
  * 集約がイベントを作成してイベントを作成して、イベントパブリッシャーに渡す
  * イベントパブリッシャーがイベントを発火する。各サブスクライバに処理を委ねる。
  * ex. ユーザコンテキストの集約がユーザ削除イベントを作成してイベントパブリッシャーに渡す。イベントパブリッシャーはユーザへメールを送るサブスクライバや、itemコンテキストにも削除を依頼するサブスクライバに処理をお願いする。

* モジュール
  * 外部公開されない集約

# 第1章

## 1.3
* ユビキタス言語をドキュメント化してそれを保存するのは得策ではない。
* チームでの会話やコード内のモデルが今のドメインのユビキタス言語で表現されているので、それが正である。

## 1.4
* 技術的な面白みというよりも、事業価値を高めることに繋がることに良さがある。
* コアドメインに力を入れる => 場合によってはモノリシックな「その他」ドメインができたりするのだろうか？ => 多分それをやってもいい。
  * コアドメインを汚さないように隔離することで、最低限のラインを保てる。
* うまく設計されたモデルと単にセッターゲッターを設定しただけのモデルの関係は、Ruby と C++ の違いに似たものを感じた。すなわち、文脈を意識して使い所に即したものをユーザに提供するかどうかという意味合いにおいて。

## 1.5
* 戦略だけやって戦術はやらない、みたいな方法はとるとどうなる？
  * 境界づけられたコンテキストでドメインが別れているので、大負けはしない。
  * が、そのドメインの中がごちゃごちゃになるので戦術的モデリングをやった方が良い。


# 第2章

## 2.1
* 広義のドメインの中にコアドメインとサブドメインがある。
* サブドメインとコアドメインの違い => 後者はビジネス的な価値の源泉となるもの
* 汎用サブドメインとしてのロギング機能とかは、複数の協会づけられたコンテキストにまたがる、サブドメインとなる。
* 「サブドメインは、複数の境界づけられたコンテキストにかかわっているだろうか？もしそうだとしても、別に問題はない。業務ソフトウェアとはそういうものだ。」
  * ひとつのサブドメインのなかに複数の境界づけられたコンテキストがあるケース
    * SEOサブドメインの中に sitemap コンテキストと canonical コンテキストがある、とか。
    * これは普通にあってよい
  * 一つの境界づけられたコンテキストが複数のサブドメインに関わっているケース
    * 外部サービスを買ってきたケース(ERPとか)
    * pixta.git みたいなモノリスもこれにあたると思われる
    * これはできれば避けたい

## 2.2
* コンテキストはライブラリという形でも良い(3.1にある、共有カーネル)。
  * したがってユーザ認証コンテキストとか、パーミッションコンテキストとかもAPIコール出なくて↑みたいにやることも可能。

## 2.3
* 問題空間と解決空間
  * 前者は、問題発見フェーズ。
    * そもそもそのドメインにおける問題発見をするためには、どのようなサブドメインからドメインが成り立ち、そのサブドメインがどのような関係性を持っているかを明確に理解しておく必要がある。
    * なので、それを考えるのが問題空間
  * 後者は、前者で見つけたドメインをどう現実的に実現するか。問題解決フェーズ。
    * なので、境界づけられたコンテキスト(アーキテクチャと対応することが多い)を見つけてそれをどう実装するかを考えることになる。
* 図2.4 とその後の「そのドメインの各部分を担当するのは誰？」からわかるように、チーム分割はドメインの境界面で行う！！！
* ERP を何も考えずに使っていると、コンウェイの法則に従って ERP チームみたいになってしまうだろうが、それだと問題空間を反映したものとなっていないので、適切なビジネス課題の発見ができないだろう。
* 問題空間(サブドメイン)を解決空間で表す時に、複数の境界づけられたコンテキストがあることは普通にあり得る。
  * 特に外部のAPIを叩く時には必ずそうなるんじゃないかな？

## 2.4
* サブドメイン、境界づけられたコンテキストは、問題空間の概念
* items の場合だと、審査前、審査中、審査後とかでわけてそれぞれ別の境界づけられたコンテキストを用意して、別のDBを用意して入れておくことになる。
* 境界づけられたコンテキストは、言語により規定されるので、ドメインモデル以外のものが入ってもよい。
* 境界づけられたコンテキストを考える際に、アーキテクチャ境界やチーム境界のことを考えるべきではない
* 境界づけられたコンテキストを GitHub のリポジトリと対応させると、場合のよってはいい感じになりそう？
  * そのなかに rails アプリケーション用のディレクトリを掘ってそこにアプリケーションを置いて、別のディレクトリにはそのユビキタス言語で表される処理をするスクリプトが置いてあったり。

## 2.5
* 責務のレイヤ => イメージとしては、認証をmoduleに切り出し、model の中でそれを取り込む感じか。その場合レイヤは別れているがモデルに残り続けていることは変わらない
* 隔離されたコア => 認証を model に切り出してしまい、手前のアプリケーションサービスから認証の model と別の model に順番にアクセスする感じか。
* カウボーイの会話: 共通の鍵を用意して、その鍵を受け取った人は全てのサイロに入れる、みたいにするべき

# 第3章
## 3.1
* 腐敗防止層(AntiCorruptionLayer)
  * 基本的には必要不可欠。なぜなら、言語の区切りが境界づけられたコンテキストの区切りだから。
  * 下流側が腐敗防止層
* 公開ホストサービス(OpenHostSeavice)
  * 「サブシステムにアクセスできるようにするプロトコルを、サービスの集合として定義すること」
    * APIを提供する的な。
* 公表された言語(PublichedLanguage)
  * 供給者側が、「こういう言語で公開しているから使ってね」としているもの
  * 本を読む感じ、二つの境界づけられたコンテキストの間での共有言語をもとに公表するように見えるが、これは無理があるのでは？と感じた。それだと、O(n^2)のペースで公表された言語が増えていく。
  * 供給者側がユビキタス言語で公表する方が良いのでは？
* ↓でペアなイメージ
  * パートナーシップ と 順応者
  * 顧客/供給者の関係 と 腐敗防止層/公開ホストサービス/公表された言語
* 下流のモデルがなるべく上流のモデルに依存しないようにするやつ、どう実装するのだろうか？
  * 例えば認証コンテキストのアーキテクチャが停止したらどうするのだろうか？
  * 腐敗防止層でエラー処理ちゃんとするということかと思った。
  * ログイン情報を保存しておいて、一定時間は認証コンテキストを叩かなくて済む、みたいにするのもありか。

* RPC は internal API をイメージすれば良い。
* 依存性を減らすのであれば、キャッシュとかで必要な最小限の状態だけを、そのローカルのドメインオブジェクトとして変換して持っておく。
* 同期は、リモートシステム側からの通知。
* 同じイベントを重複して処理しないようにケアするのは、クライアント側の責務


# 4章
## 4.1
* Rails でいうと、
  * UI: view
  * アプリケーション: controller
  * ドメイン: model から db とのmapperの部分を除いた者
  * インフラ: mapperとDB、外部API叩く層など
* 「リポジトリインターフェイスが要求している実装が。永続化メカニズムなどのコンポーネントを要求するものであり、それはインフフラストラクチャに存在するものだとしよう」？？？

## 4.2
* ドメイン層はビジネスに依存しており、それ以外には依存しないようにしたい。
* ドメインが変わればドメインに依存している他の全てが変わるのは問題ないが、ビジネス以外のことが変わってドメインが変わるのはおかしい。
* ドメインがインフラに依存している状況: ドメインで update するときに MySQLClient.update() みたいなことをしていたら、そうなっている
* ドメインがインフラに依存していない状況: UserRepository.update_user_name とかにしておき、UserRepository の内部で DB を選んで接続している場合とか

## 4.3
* ヘキサゴナルアーキテクチャ
  * アプリケーションサービスとドメインモデルを内部に置き、それとそれ以外をきっぱり分けて、I/Oに依らず統一的なインタフェースを使うようにする

## 4.4
* SOA(Service Oriented Architecture)
  * アプリケーションサービスとドメインモデルがまずあり(境界づけられたコンテキストに基づく)、そいつらをうまく使えるラッパー的なノリでサービスというのを用意する
  * サービスはユースケースにあわせて作られるが、ドメインモデルがそれに依ってはならない
  * 図4-5 のアダプターEは、ORMapper とかか。

## 4.5
* REST
  * リソースに対して何かする、という感じにしなければならないのに、まとめていろんなことをやってしまうことがあって、それはアンチパターン

## 4.6 CQRS
* Read(クエリ)とWrite(コマンド)が別々に分かれていると、view依存の物を完全に分けることができる
* コマンドはそれに対応する結果確認用のクエリを概念上考えることができるので、クエリ集合からコマンド集合に対する全射fを定義できそうだなとか思った。

## 4.7 イベント駆動アーキテクチャ
* リアルタイムでユーザに結果を伝える必要がないものについては有用。
* イベントソーシング
  * ドメインモデル内の任意の集約のインスタンス上で実行された全ての操作コマンドを、その実行結果を示す少なくとも一つのドメインイベントとして発行する。
  * それを繰り返せば状況が再現できるようなもの。
  * ヘキサゴナルアーキテクチャを跨いでいるから、そういうことが必要になる(ひとつのアーキテクチャの中だったら、ソースコード読めば済むし)
* ピクスタではデジタル素材を扱っているがゆえに、カスタマー側を考えるとこういう非同期処理はなかなか出てこない

## 4.8
* キャッシュに残しておけばパフォーマンスが上がるよね => データファブリック
* 集約そのものをシリアライズ、と書いてあったので Ruby でいうと Marshal 使うみたいな感じなのだろうか


# 5章 エンティティ
## 5.1
* ドメインモデルは、エンティティと値オブジェクトのどちらかに大別される。
* アイデンティティを持たないものが値オブジェクト。id が違うなら違うもの、とするのがエンティティ。
## 5.2
* エンティティのユニークIDをどう生成し保持していくか、という話が書いてある。4つのやり方。
  * ユーザが入力
  * アプリケーションが内部で生成
  * データベースなど永続化層が生成
  * 別の境界づけられたコンテキストのものを使う

## 5.3
* 具体、という感じ。
* バリデーションをエンティティ自体がしなくても良いが、クライアント側からはエンティティがやっているように見せる必要がある(安心させることができる)。エンティティ自体がしない、というのは、specific なバリデーションクラスみたいなのを用意してそれをエンティティが呼び出せば良い、という意味



# 6章 値オブジェクト
## 6.1
* value_object.rb に例を書いた

## 6.2
* API提供側ではエンティティだが、使う側では値オブジェクトとする。と良い。Read only なときは特にそう。
* write するときは、下流側でもエンティティを定義する、という選択肢もある。できれば避けたいが。

## 6.3
* enum の値をインスタンス変数として持つとか、継承でもできそうだし、依存オブジェクトの注入

## 6.4
* ドメインのインタフェースを考えようという話かと。

## 6.5
* 値オブジェクトのコンストラクタ二つ。
  * ひとつは属性全てを引数に取り、新規作成するもの
  * もう一つは、シャローコピーするもの。(それが適切な値オブジェクトならば、ディープコピーの必要性はないはず)


## 6.6
* 「可能な限り、ドメインモデルを考慮してデータモデルを設計するようにしよう。ドメインモデルがデータモデルの設計に縛られるようではいけない。前者はドメインモデルの視点で考えるということであり、後者は永続化の視点でかんがえるということになる」
* 「基本的なアイデアは、値を保持するエンティティが格納されているテーブルの行に、値の各属性に対応したカラムを用意するというものだ」言い換えると、単一の値オブジェクトを非正規化して、親のエンティティの行に組み込むということになる。」
* ↑のふたつが言っていることから考えたこと
  * Rails でモデルがどういうものなのかを調べるときに、とりあえずDBのテーブル定義を見ることがある。しかしこれは、DDD 的な発想ではないと言える。
  * あくまでドメインモデルの I/F から出発すべき。
  * ただし、Rails においてはモデルとDBが密結合なので、こういうことをしてしまうのは自然であり、それにより問題は起きない。


# 7章 サービス
## 7.1
* ここでは、ドメインサービスについて扱っている。
* アプリケーションサービスはドメインの外にあるものだが、ドメインサービスはドメインの一部。
* ピクスタでいうと SitemapGenerator 。
* rails でいう controller はアプリケーションサービスか。userが解約するときにuserのステータスとitemの停止を同時に行うときに、解約を行う処理はドメインサービスとなる。
* カウボーイの声。ドメインサービスはステートレスで永続化しないので、「それが何であるのかは別に気にしなくていい」つまり、バリデーションはしなくていいということ。

## 7.2
* 具体例
## 7.3
* UserDescriptor クラスを作ってそいつに tenantId と userId を持たせる。というところが面白い。
  * authenticate した場合のみ見れる情報を持たせる
* 自分だったら AuthenticationService().exec とかして、その戻り値を boolean にしてしまっていたかも。
## 7.4
* セパレートインタフェース
  * EncryptionServiceインターフェースをドメインモデルに置き、その暗号化の具体的な方法はインフラストラクチャ側で行う。そうすると、MD5以外の暗号化に変えることが容易になる。


# 8章 ドメインイベント
## 8.1
* メーセージキューとか、非同期実行もドメインイベントか。
## 8.2
* 例えば imasia から pixta に対して、ダウンロードされたことを伝える時は？
  * 「ダウンロードされました」イベントなのか、「クレジット付与してくれ」イメントや「クリエイターにメールしてくれ」イベントなのか
  * 前者だろう。あくまでパブリッシャ側のユビキタス言語で。
  * 誰に通知するのか？をimasiaは知っているのか？
* 「軽量なサブスクライバ」と書いてあるやつは、中継をしている。すなわち、イベントパブリッシャーが発行したイベントをサブスクライブし、必要としているサブスクライバのメッセージキュー(サブスクライバと一対一対応と考えている)にパブリッシュする。
  * 中継している主体は、何が来たらどれとどれに送るか、を知っているが、それは「XXXが来たらそれは私のメッセージキューに積んでください」と各ドメインがその主体にお願いした結果そうなっている的なイメージ。
  * 中継している主体は汎用サブドメインなのではないか？サブスクライバにメッセージを送り続け、それをうまく処理できたかを確認するが、うまく処理できていなかったらエラー通知をする、とか

## 8.3
* domain_event.rb に書いた
* Rails でいうと ActiveJob でできる
* サブスクライバをパブリッシャーに登録するのはアプリケーションサービスにおいて。

## 8.4
* 以下のいずれかでパブリッシュしたイベント情報を永続化する
  * 1. メッセージング基盤の永続化ストアを全サービスで共有する
  * 2. ドメインモデルの永続化ストアとメッセージング用の永続化ストアを二相コミットで制御する
  * 3. ドメインモデルの使っているデータストアそれぞれでメッセージング基盤の永続化ストアを保持する
