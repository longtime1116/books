# この本の前に

- Kubernetes の構成コンポーネント一覧([参考記事](https://qiita.com/tkusumi/items/c2a92cd52bfdb9edd613))
  - Master
    - etcd
      - 永続化を行う KVS
    - apiserver
      - kubectl コマンドを受けて認証・認可、CRUD 操作
    - scheduler
      - Pod のノードへの割り当てを行う。
    - controller manager
      - 各種リソースのコントローラを起動するマネージャー
      - 各種リソースとは、ReplicationManager とか、NodeController とか、DaemonSetsController とか。
  - Node
    - kubelet
      - Node のメイン処理である Pod の起動・管理を行う
    - container runtime
    - kube-proxy
      - ネットワークプロキシ、ロードバランサーを提供

# 1 章
- Kubernetes のメリット
  - ベロシティ
    - イミュータブル
      - バージョンの違いによりサービスの差分がわかるので、問題発生時に原因を突き止めやすい
      - 古いイメージを残しておけるので、ロールバックが容易
    - 宣言的設定
    - 自己回復するシステム
      - 宣言的設定をしているので、宣言と状態が違うのであれば宣言の状態に戻す、ということができる。
      - オペレータの責任を軽減でき、信頼性の高い復旧策をより早く実行でき、システムの信頼性を向上させる。
  - サービスとチームのスケール
    - 分離
      - 各コンポーネントが API とロードバランサにより分けられている。
      - コンポーネントをロードバランサで分離すると、サービスのスケールが容易になる。
      - 外部との接触部分が明確なマイクロサービスごとにチームを分けることができ、チームのスケールも容易になる。
    - アプリケーションとクラスタの簡単なスケール
      - 宣言的設定のおかげで、設定ファイルの数字を変えるだけでスケール可能。また、オートスケール設定しておけばそれすら不要。
      - Kubernetes で複数サービスをまとめて管理すると、複数サービスの合計のコストを予測できるので、コスト予測が容易になる。
    - マイクロサービスによる開発チームのスケール
      - マイクロサービスごとにチーム分けができるため、「ピザ2マイ分のチーム」(6〜8名)のチームを維持しやすい。
        - 以下のような抽象化層やAPIが、マイクロサービスアーキテクチャの実現を容易にしている。
          - Pod
            - デプロイ可能な1つの単位としての、コンテナイメージのグループ
          - Service
            - ロードバランシングやネーミング、ディスカバリの機能を提供
          - Namespace
            - マイクロサービス動詞の連携範囲を制御するため、分離とアクセス制御をおこなう
          - Ingress
            - 複数のマイクロサービスをまとめて谷津の外部からアクセス可能なAPIを提供できる、簡単なフロントエンドを提供する
    - 一貫性とスケールのための依存関係の切り離し
      - アプリケーションとクラスタのレイヤ間を、Kubernetes API によって切り離すことができるので、依存関係が解消される。
  - インフラの抽象化
    - Kubernetes によって特定のクラウドを抽象化すると、ポータブルな管理ができるようになる。
    - なので、クラウドマネージドサービスを使うのは逆行した行動となる(例えば DynamoDB をつかうと、AWS の DynamoDB の SDK を使って実装をする必要があるので、複数のクラウドでアプリケーションを動かすのが難しくなる。)
  - 効率性
    - 複数のユーザからのタスクを、少数のマシンで必要最低限のリソースで実行できるようになる。経済的にコスト削減となる。
# 2 章
# 3 章
