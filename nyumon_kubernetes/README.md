# この本の前に

- Kubernetes の構成コンポーネント一覧([参考記事](https://qiita.com/tkusumi/items/c2a92cd52bfdb9edd613))
  - Master
    - etcd
      - 永続化を行う KVS
    - apiserver
      - kubectl コマンドを受けて認証・認可、CRUD 操作
    - scheduler
      - Pod のノードへの割り当てを行う。
    - controller manager
      - 各種リソースのコントローラを起動するマネージャー
      - 各種リソースとは、ReplicationManager とか、NodeController とか、DaemonSetsController とか。
  - Node
    - kubelet
      - Node のメイン処理である Pod の起動・管理を行う
    - container runtime
    - kube-proxy
      - ネットワークプロキシ、ロードバランサーを提供

# 1 章
- Kubernetes のメリット
  - ベロシティ
    - イミュータブル
      - バージョンの違いによりサービスの差分がわかるので、問題発生時に原因を突き止めやすい
      - 古いイメージを残しておけるので、ロールバックが容易
    - 宣言的設定
    - 自己回復するシステム
      - 宣言的設定をしているので、宣言と状態が違うのであれば宣言の状態に戻す、ということができる。
      - オペレータの責任を軽減でき、信頼性の高い復旧策をより早く実行でき、システムの信頼性を向上させる。
  - サービスとチームのスケール
    - 分離
      - 各コンポーネントが API とロードバランサにより分けられている。
      - コンポーネントをロードバランサで分離すると、サービスのスケールが容易になる。
      - 外部との接触部分が明確なマイクロサービスごとにチームを分けることができ、チームのスケールも容易になる。
    - アプリケーションとクラスタの簡単なスケール
      - 宣言的設定のおかげで、設定ファイルの数字を変えるだけでスケール可能。また、オートスケール設定しておけばそれすら不要。
      - Kubernetes で複数サービスをまとめて管理すると、複数サービスの合計のコストを予測できるので、コスト予測が容易になる。
    - マイクロサービスによる開発チームのスケール
      - マイクロサービスごとにチーム分けができるため、「ピザ2マイ分のチーム」(6〜8名)のチームを維持しやすい。
        - 以下のような抽象化層やAPIが、マイクロサービスアーキテクチャの実現を容易にしている。
          - Pod
            - デプロイ可能な1つの単位としての、コンテナイメージのグループ
          - Service
            - ロードバランシングやネーミング、ディスカバリの機能を提供
          - Namespace
            - マイクロサービス動詞の連携範囲を制御するため、分離とアクセス制御をおこなう
          - Ingress
            - 複数のマイクロサービスをまとめて谷津の外部からアクセス可能なAPIを提供できる、簡単なフロントエンドを提供する
    - 一貫性とスケールのための依存関係の切り離し
      - アプリケーションとクラスタのレイヤ間を、Kubernetes API によって切り離すことができるので、依存関係が解消される。
  - インフラの抽象化
    - Kubernetes によって特定のクラウドを抽象化すると、ポータブルな管理ができるようになる。
    - なので、クラウドマネージドサービスを使うのは逆行した行動となる(例えば DynamoDB をつかうと、AWS の DynamoDB の SDK を使って実装をする必要があるので、複数のクラウドでアプリケーションを動かすのが難しくなる。)
  - 効率性
    - 複数のユーザからのタスクを、少数のマシンで必要最低限のリソースで実行できるようになる。経済的にコスト削減となる。
# 2 章

# 3 章
- https://qiita.com/longtime1116/items/72d06a91747246ceb3a7

# 4 章

# 5 章 Pod
- Pod は、Kubernetes クラスタ場での最小のデプロイ単位
- 同じ実行環境場で動くアプリケーションコンテナとストレージボリュームの集まり
- 同じ Pod 内のアプリケーションは、同じ IP アドレスとポートを使用し、同じホスト名を持つ。
- Pod を分けるかどうか？の判断基準は、「このコンテナはそれぞれ違うマシンに配置されても正常に動作するか？」を考えてみると良い。
- Volume と Pod を組み合わせることで、データを永続化することができる。


# 6 章 Label と Annotation
- Label
  - Pod や ReplicaSet といった Kubernetes オブジェクトに付与できる、key と value のペア
  - オブジェクトをグルーピングするためのもの。
  - ex)
    - app.version: 1.0.0
    - app: alpaca
    - env: proj
  - Label セレクタを使って、表示したい Pod のみ表示する、みたいなことができる。
- Annotation
  - ツールやライブラリを手助けするための、メタデータを保存する入れ物。Label と同様、Kubernetes オブジェクトに付与できる。
  - Label と違って、オブジェクトがどこから来たのか、どのように使うのか、どのようなポリシーなのかといった追加情報を提供するために使う。
  - Label と Annotation のどちらを使うかは、好みによるところも大きい。

# 7 章 サービスディスカバリ
- Kubernetes は非常にダイナミックなので、たくさんのサービスを同時に実行可能できる一方、動いているサービスを見つけるのは難しくなる。
- サービスディスカバリツールを使うと、ユーザは必要な情報を必要に応じてすばやく確実に見つけられる。(例えば、DNS はインターネット上のサービスディスカバリと言える)
- Kubernetes においては、Service オブジェクトがサービスディスカバリのキーとなる。
- Service オブジェクトは名前のついた Label セレクタを作る仕組みであり、うまく用いることでクラスタ内外に対してサービスを後悔するための柔軟で強力な方法となる。アプリケーションが動的にサービスを見つけ、動的なアプリケーションな配置に対応できるようになると、いつどこで何が動いているかを考える必要がなくなる。

# 8 章 ReplicaSet
- 冗長性、スケール、シャーディングの観点から、一度にコンテナのレプリカを複数動かしたくなる。
- Pod マニフェストを使って Pod のコピーを手動で作るのはしょうもないので、レプリカ群をまとめて管理したい。
- それを実現するのが ReplicaSet。
- 指定したテンプレートに従った正しい数の Pod が常に動いているようにすることができる。
- これは、アプリケーションを自己回復させる基盤となる。

# 12 章 Deployment
- Deployment オブジェクトは、新しいバージョンのリリースを管理する仕組み。
- ダウンタイムやエラーを発生させずに、新しいバージョンのソフトウェアをシンプルにかつ確実にロールアウトできる。
- エラーが発生したらデプロイを停止する、なども可能。
- Deploy 戦略として、以下の二つがサポートされている
  - Recreate 戦略
    - Deployment に関連づいた Pod をすべて停止し、新しいイメージですべての Pod を再作成する。
    - 高速でシンプルだが、壊滅的な障害を引き起こす可能性があり、そうでなくてもある程度のダウンタイムは避けられない
    - ユーザ後悔している状態ではやらないことが多い
  - RollingUpdate 戦略
    - 少数の Pod ずつ、新しいイメージで再作成して Deploy していく。

# 13 章 ストレージソリューションと Kubernetes の統合
- アプリケーションとその状態の情報を切り離し、マイクロサービスをできる限りステートレスに構築すると、システムの信頼性が最大化され、管理しやすくなる。
- しかし、ステートフルな情報を DynamoDB など「クラウドネイティブな」ストレージソリューションを使う場合は、主導或いは命令的な手順を踏まないとレプリケーションされた信頼性の高いシステムを構築できない。
- Kubernetes 上では、StatefulSet/PersistentVolumeClaim/Liveness probe という Kubernetes オブジェクトを使うことで、「クラウドネイティブな」ストレージソリューションを、Kubernetes クラスタ上で堅牢かつスケーラブルに動かすことができるようになる。
